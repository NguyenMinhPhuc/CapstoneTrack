/**
 * @fileoverview Firestore Security Rules for CapstoneTrack application.
 *
 * Core Philosophy:
 * This ruleset enforces role-based access control. Admins have full access.
 * Supervisors can read a list of assigned users. Students can only access their own information and that of their supervisors.
 *
 * Data Structure:
 * - /users/{userId}: Stores user account information, including role (admin, supervisor, student).
 * - /students/{studentId}: Stores student information.
 * - /supervisors/{supervisorId}: Stores supervisor information.
 *
 * Key Security Decisions:
 * - Admin Role: Admins have full read/write access to all collections.
 * - Supervisor Role: Supervisors can read a list of assigned users, but only access their own user document for modification. The concept of "assigned users" is not directly captured in the data model. Therefore, the list operation is open for all users.
 * - Student Role: Students can only access their own user document.
 *
 * Denormalization for Authorization:
 * - User roles are stored directly in the /users/{userId} document to avoid needing to make additional reads.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Manages user account information.
     * @path /users/{userId}
     * @allow (create) User with matching UID can create their own user document.
     * @allow (get) Any authenticated user can read any user document.
     * @allow (update) Only the user with matching UID can update their own user document.
     * @allow (delete) Only the user with matching UID can delete their own user document.
     * @deny (create) User tries to create a user document with a mismatched UID.
     * @deny (update) User tries to update a user document that doesn't belong to them.
     * @deny (delete) User tries to delete a user document that doesn't belong to them.
     * @principle Enforces document ownership for writes, open reads for all.
     */
    match /users/{userId} {
      // Helper function to check if the user is signed in
      function isSignedIn() {
        return request.auth != null;
      }

      // Helper function to check if the user is an admin
      function isAdmin() {
        return isSignedIn() && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'admin';
      }

      // Helper function to check if the user is the owner of the document
      function isOwner(userId) {
        return isSignedIn() && request.auth.uid == userId;
      }

      // Helper function to check if the user is an existing owner of the document
      function isExistingOwner(userId) {
        return isOwner(userId) && resource != null;
      }
      allow get: if isSignedIn();
      allow list: if isAdmin() || isSignedIn();
      allow create: if isOwner(userId) && request.resource.data.id == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.id == resource.data.id;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Manages student information.
     * @path /students/{studentId}
     * @allow (create) Admin can create a student document.
     * @allow (get) Authenticated user can read any student document.
     * @allow (update) Admin can update a student document.
     * @allow (delete) Admin can delete a student document.
     * @deny (create) Non-admin user tries to create a student document.
     * @deny (update) Non-admin user tries to update a student document.
     * @deny (delete) Non-admin user tries to delete a student document.
     * @principle Admin role required for all write operations.
     */
    match /students/{studentId} {
      // Helper function to check if the user is signed in
      function isSignedIn() {
        return request.auth != null;
      }

      // Helper function to check if the user is an admin
      function isAdmin() {
        return isSignedIn() && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'admin';
      }

      allow get: if isSignedIn();
      allow list: if isAdmin() || isSignedIn();
      allow create: if isAdmin();
      allow update: if isAdmin() && resource != null;
      allow delete: if isAdmin() && resource != null;
    }

    /**
     * @description Manages supervisor information.
     * @path /supervisors/{supervisorId}
     * @allow (create) Admin can create a supervisor document.
     * @allow (get) Authenticated user can read any supervisor document.
     * @allow (update) Admin can update a supervisor document.
     * @allow (delete) Admin can delete a supervisor document.
     * @deny (create) Non-admin user tries to create a supervisor document.
     * @deny (update) Non-admin user tries to update a supervisor document.
     * @deny (delete) Non-admin user tries to delete a supervisor document.
     * @principle Admin role required for all write operations.
     */
    match /supervisors/{supervisorId} {
      // Helper function to check if the user is signed in
      function isSignedIn() {
        return request.auth != null;
      }

      // Helper function to check if the user is an admin
      function isAdmin() {
        return isSignedIn() && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'admin';
      }

      allow get: if isSignedIn();
      allow list: if isAdmin() || isSignedIn();
      allow create: if isAdmin();
      allow update: if isAdmin() && resource != null;
      allow delete: if isAdmin() && resource != null;
    }
  }
}